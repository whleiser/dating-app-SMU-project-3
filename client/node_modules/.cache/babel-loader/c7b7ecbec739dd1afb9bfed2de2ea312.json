{"ast":null,"code":"export default {\n  /**\n   * cross browser addEvent\n   * @param {string}   event The event to add\n   * @param {Function} fn    [description]\n   */\n  add: function add(element, event, fn) {\n    // check if element is a compoenent\n    element = element.root || element; // avoid memory overhead of new anonymous functions for every event handler that's installed\n    // by using local functions\n\n    function listenHandler(e) {\n      var ret = fn.apply(this, arguments);\n\n      if (ret === false) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n\n      return ret;\n    }\n\n    function attachHandler() {\n      // set the this pointer same as addEventListener when fn is called\n      // and make sure the event is passed to the fn also so that works the same too\n      var ret = fn.call(element, window.event);\n\n      if (ret === false) {\n        window.event.returnValue = false;\n        window.event.cancelBubble = true;\n      }\n\n      return ret;\n    }\n\n    if (element.addEventListener) {\n      element.addEventListener(event, listenHandler, false);\n    } else {\n      element.attachEvent('on' + event, attachHandler);\n    }\n\n    return this;\n  },\n\n  /**\n   * cross browser removeEvent\n   * @param  {string}   event The event to remove\n   * @param  {Function} fn    [description]\n   * @return {Object}         [description]\n   */\n  remove: function remove(element, event, fn) {\n    element = element.root || element;\n\n    if (element.removeEventListener) {\n      element.removeEventListener(event, fn, false);\n    } else if (element.detachEvent) {\n      element.detachEvent('on' + event, element[fn.toString() + event]);\n      element[fn.toString() + event] = null;\n    } else {\n      element['on' + event] = function () {};\n    }\n\n    return this;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}